#!/bin/bash
#
# pbrisbin 2010
#
# fully inspired by http://github.com/rson/shop
#
# cando will tell you if a specific user can perform a specific action
# on a file or directory. it does this not just by checking ownership
# and permissions but also verifing that the user can enter each of the
# parent directories required to even get to the file in question.
#
# examples:
#
#  //blue/0/~/ cando mpd r Music/
#  cando:  ---  /home/patrick/Music/
#
#  //blue/0/~/ cando http rwx /srv/http/*
#  cando:  rwx  /srv/http/app.cgi
#  cando:  r-x  /srv/http/cassius
#  cando:  rw-  /srv/http/client_session_key.aes
#  cando:  rw-  /srv/http/comments.db
#  cando:  r--  /srv/http/favicon.ico
#  cando:  r-x  /srv/http/hamlet
#  cando:  r-x  /srv/http/pandoc
#  cando:  r-x  /srv/http/static
#  cando:  r-x  /srv/http/xmonad
#
###

errorout() { echo "error: $*" >&2; exit 1; }
message()  { echo "usage: cando <user> <perms> <file> ..."; exit 1; }

# parse stat -c to get user, group, and octal permissions on the passed
# directory or file
set_info() {
  unset mode owner group
  IFS=':' read -r mode owner group < <(stat -c "%a:%U:%G" "$1")
}

# walk up a filepath tree checking at each level that the arg user can
# enter each directory, else we shouldn't even bother checking the
# permissions on the file itself
can_access() {
  local absolute

  absolute="$(readlink -f "$1")"
  cd "$(dirname -- "$absolute")" || errorout 'failed to change directory'

  while [[ "$PWD" != '/' ]]; do
    set_info "$PWD"
    can_exec || return 1
    cd ..    || errorout 'failed to change directory'
  done
}

# helper checks
is_owner() { [[ "$user" == "$owner" ]];                       }
in_group() { groups "$user" 2>/dev/null | grep -Fqw "$group"; }

has_mode() {
  local arg num

  if is_owner; then
    num="${mode:0:1}"
  elif in_group; then
    num="${mode:1:1}"
  else
    num="${mode:2:1}"
  fi

  for arg in "$@"; do
    [[ $arg -eq $num ]] && return 0
  done

  return 1
}

# check each possible incarnation of the required permissions to perform
# each action
can_read()  { has_mode 7 6 5 4; }
can_write() { has_mode 7 6 3 2; }
can_exec()  { has_mode 7 5 3 1; }

process_file() {
  local file="$1"

  if [[ ! -e "$file" ]]; then
    echo "$file: does not exist" >&2
    return
  fi

  echo -n 'cando:  '
  if can_access "$file"; then
    set_info "$file"

    if [[ "${perm/r/}" != "$perm" ]]; then
      can_read && echo -n 'r' || echo -n '-'
    fi

    if [[ "${perm/w/}" != "$perm" ]]; then
      can_write && echo -n 'w' || echo -n '-'
    fi

    if [[ "${perm/x/}" != "$perm" ]]; then
      can_exec && echo -n 'x' || echo -n '-'
    fi
  else
    echo -n '---'
  fi
  echo "  $file"
}

# get options
parse_options() {
  [[ "$#" -lt 3 ]] && message
  user="$1"; shift
  perm="$1"; shift

  # validate options
  grep -q "^$user" /etc/passwd || errorout "$user: user does not exist"
  echo $perm | grep -q [^rwx]  && errorout "$perm: invalid mode"
  
  files=( "$@" )
}

parse_options "$@"

for f in "${files[@]}"; do
  process_file "$f"
done
