#!/bin/bash
#
# pbrisbin 2010
#
# http://code.google.com/p/android-notifier/
#
# accept incoming messages from android-notifier and hand them off to
# handle_message().
#
###

errorout() { echo "error: $*" >&2; exit 1; }

message() { echo 'usage: android-receiver [start|stop|restart]'; exit 1; }

# best function name ever. note: this assumes one child per parent at
# each level, it is not a generic implimentation.
kill_children() {
  local ppid=$1 pid

  while [[ -n "$ppid" ]]; do
    # locate the child
    pid=$(ps -o ppid,pid ax | sed -r '/^'"$ppid"' ([0-9]+)/!d;s//\1/')

    # kill parent
    kill $ppid

    # reset and loop
    ppid=$pid
  done
}

# starts the daemon listening in the background, calls convert_message
# when something's received
start_daemon() {
  [[ -f "$pid_file" ]] && errorout "file found at $pid_file, already running?"

  # start listening in background
  ( while read -d $'\0'; do
      convert_message "$REPLY"
    done < <($listen) ) &

  echo "$!: listening..." >&2
  echo $! > "$pid_file"
}

# stops the daemon using the pid file
stop_daemon() {
  local pid

  if [[ -f "$pid_file" ]]; then
    read pid < "$pid_file"  
    kill_children $pid || errorout 'error stopping daemon'
    rm "$pid_file"
  fi
}

# splits the message into fields and hands them off to handle_message
# for actual display; todo: use awk
convert_message() {
  local message="$1"
  local v d_num m_num m_type m_data m_contents

  # todo: we only handle v2 messages for now
  while IFS='/' read -r v d_num m_num m_type m_data m_contents; do
    handle_message "$d_num" "$m_num" "$m_type" "$m_data" "$m_contents"
  done <<< "$message"
}

# handle the message however you see fit: notify-osd, gnome-dbus, dzen,
# whatever.
handle_message() {
  local device="$1"       # device id
  local notification="$2" # notification id
  local event_type="$3"   # event type: RING, SMS, MMS, BATTERY, PING
  local data="$4"         # data: percent battery left, sender number, etc
  local contents="$5"     # contents: human readable information

  case "$event_type" in
    RING)          handle_dzen "  !! Call from $contents..." ;;
    SMS|MMS|PING)  handle_dzen "  !! $contents"              ;;
    esac
}

# handle the event via dzen. this just throws $* into the dzen, so do
# any text formatting before passing into this function
handle_dzen() {
  local message="$*"

  # dzen settings
  local pipe='/tmp/android-receiver.fifo'
  local delay=4
  local x_offset=0
  local y_offset=0
  local height=17
  local font='Verdana-8'
  local foreground='#ffffba'
  local background='#303030'

  if [[ ! -e "$pipe" ]]; then
    mkfifo "$pipe"
    (dzen2 -ta l -h $height -x $x_offset -y $y_offset -fn "$font" -bg $background -fg $foreground < "$pipe"; rm -f "$pipe") &
  fi

  # todo: make this prettier
  (echo "$message"; sleep $delay) >> "$pipe"
}

# the commant that's used to listen for incoming messages, just incase
# we want to tweak the ip or port
listen='netcat -z -u -l -p 10600 localhost'

# a place to store the pid when we start the daemon so that we can
# effectively kill it later
pid_file='/tmp/android-reciever.pid'

# run
case "$1" in
  start)   start_daemon  ;;
  stop)    stop_daemon ;;
  restart) stop_daemon
           sleep 3
           start_daemon ;;
  *)       message ;;
esac
